# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ILbq2MJXhf1c70ZlDZcnc8vv1nPdV-HB
"""

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!kaggle datasets download -d paultimothymooney/chest-xray-pneumonia

zip_path = '/content/chest-xray-pneumonia.zip'
!unzip -q {zip_path} -d .
!rm {zip_path}
zip_path = '/content/chest_xray.zip'

from PIL import Image

# Load the image
image = Image.open('/content/chest_xray/val/NORMAL/NORMAL2-IM-1427-0001.jpeg')

# Get the size of the image
width, height = image.size
print(f"Width: {width}, Height: {height}")

# Check the color mode (e.g., RGB, RGBA, L for grayscale)
color_mode = image.mode
print(f"Color Mode: {color_mode}")

# Display the image
image.show()

import numpy as np
import os
import cv2
from tqdm import tqdm
import tensorflow as tf
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Dense, Dropout, Activation, Flatten, Input, MaxPooling2D, Conv2DTranspose, Conv2D, Concatenate, BatchNormalization, Activation, GlobalAveragePooling2D
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau

image_size= 224,224
batch_size=32

train_dir = '/content/chest_xray/train'
test_dir = '/content/chest_xray/test'
val_dir = '/content/chest_xray/val'

train_ds = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
)

val_ds = ImageDataGenerator(
    rescale=1./255
)
train_ds = ImageDataGenerator(rescale=1./255)

train_gen = train_ds.flow_from_directory(
    train_dir,
    target_size=image_size,
    batch_size=batch_size,
    class_mode='binary',
    shuffle=True
)
val_gen = val_ds.flow_from_directory(
    val_dir,
    target_size=image_size,
    batch_size=batch_size,
    class_mode='binary',
    shuffle=True
)
test_gen = val_ds.flow_from_directory(
    test_dir,
    target_size=image_size,
    batch_size=batch_size,
    class_mode='binary',
    shuffle=True
)

def u_net(image_size):
    inputs = Input(image_size)
    c1 = Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(inputs)
    c1 = Dropout(0.1)(c1)
    c1 = Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c1)
    p1 = MaxPooling2D((2, 2))(c1)

    c2 = Conv2D(128, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(p1)
    c2 = Dropout(0.1)(c2)
    c2 = Conv2D(128, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c2)
    p2 = MaxPooling2D((2, 2))(c2)



    c3 = Conv2D(256, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(p2)
    c3 = Dropout(0.2)(c3)
    c3 = Conv2D(256, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(c3)
    p3 = MaxPooling2D((2,2))(c3)

    for layer in [c3]:
        layer.trainable = False
    c4 = Conv2D(512, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(p3)
    c4 = Dropout(0.2)(c4)
    c4 = Conv2D(512, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(c4)
    p4 = MaxPooling2D((2,2))(c4)

    c5 = Conv2D(1024, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(p4)
    c5 = Dropout(0.3)(c5)
    c5 = Conv2D(1024, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(c5)

    u6 = Conv2DTranspose(512, (2,2), strides=(2,2), padding='same')(c5)
    u6 = Concatenate()([u6, c4])
    c6 = Conv2D(512, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(u6)
    c6 = Dropout(0.2)(c6)
    c6 = Conv2D(512, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(c6)

    u7 = Conv2DTranspose(256, (2,2), strides=(2,2), padding='same')(c6)
    u7 = Concatenate()([u7, c3])
    c7 = Conv2D(256, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(u7)
    c7 = Dropout(0.2)(c7)
    c7 = Conv2D(256, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(c7)

    u8 = Conv2DTranspose(128, (2,2), strides=(2,2), padding='same')(c7)
    u8 = Concatenate()([u8, c2])
    c8 = Conv2D(128, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(u8)
    c8 = Dropout(0.1)(c8)
    c8 = Conv2D(128, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(c8)

    u9 = Conv2DTranspose(64, (2,2), strides=(2,2), padding='same')(c8)
    u9 = Concatenate()([u9, c1])
    c9 = Conv2D(64, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(u9)
    c9 = Dropout(0.1)(c9)
    c9 = Conv2D(64, (3,3), activation='relu', kernel_initializer='he_normal', padding='same')(c9)

    x = GlobalAveragePooling2D()(c9)
    x = Dense(512, activation='relu')(x)
    x = Dropout(0.5)(x)
    x = Dense(1, activation='sigmoid')(x)


    model = Model(inputs=[inputs], outputs=[x])
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
        # Freeze certain layers after the model is built
    for layer in model.layers[:10]:  # Modify the index range to freeze layers as needed
        layer.trainable = False

    return model
model = u_net(image_size=(224, 224, 3))

model.summary()

history = model.fit(
    train_gen,
    epochs=10,
    validation_data=test_gen,

)

print(len(train_gen))
print(len(val_gen))

print(train_gen.class_indices)  # Verify class indices
print(val_gen.class_indices)

input_shape = model.input_shape
print(f"Input shape: {input_shape}")

model.save('model.h5')

from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt

def process_image(image_path, image_size):
    img = image.load_img(image_path, target_size=image_size)
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
    img_array /= 255.0  # Normalize
    return img_array

# Path to the image and target size
img_path = '/content/chest_xray/train/NORMAL/IM-0145-0001.jpeg'
image_size = (224, 224)  # Match this to the input size expected by the model

# Process the image
img_array = process_image(img_path, image_size)

# Predict
predictions = model.predict(img_array)
predicted_prob = predictions[0,0]
predicted_class = "PNEUMONIA" if predicted_prob > 0.5 else "Normal"
# Assuming the output is a single channel and you want a binary prediction
print(f"Predicted Class: {predicted_class} (Probability: {predicted_prob: 2f})")


# Load and display the image
img = image.load_img(img_path, target_size=image_size)
plt.imshow(img)
plt.title(f'Predicted Class: {predicted_class}')
plt.axis('off')
plt.show()